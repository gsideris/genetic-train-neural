// Generated by CoffeeScript 1.7.1
var Environment, Layer, MAX_GAME_ITERATIONS, Move, MoveEast, MoveNorth, MoveObject, MoveSouth, MoveWest, Network, Neuron, PERSON_HEALTH, Person, Point, WorldMap, all_stages, convert_map_to_colors, data, decodeBase64, int, len, map_colors, network, neural_def, normalize_health, place_character, range, run_stage, shift_num, stages,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

decodeBase64 = function(s) {
  var A, L, a, b, c, e, i, l, r, w, x;
  e = {};
  i = void 0;
  b = 0;
  c = void 0;
  x = void 0;
  l = 0;
  a = void 0;
  r = '';
  w = String.fromCharCode;
  L = s.length;
  A = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  i = 0;
  while (i < 64) {
    e[A.charAt(i)] = i;
    i++;
  }
  x = 0;
  while (x < L) {
    c = e[s.charAt(x)];
    b = (b << 6) + c;
    l += 6;
    while (l >= 8) {
      ((a = b >>> (l -= 8) & 0xff) || x < L - 2) && (r += w(a));
    }
    x++;
  }
  return r;
};

$.fn.extend({
  world2d: function(options) {
    var opts, self;
    self = $.fn.world2d;
    opts = $.extend({}, self.default_options, options);
    return $(this).each(function(i, el) {
      return self.init(el, opts);
    });
  },
  place: function(x, y, content) {
    var bg, oldc, oldx, oldy;
    oldx = $(this).data("x");
    oldy = $(this).data("y");
    oldc = $(this).data("content");
    if (oldx && oldy) {
      $(this).find("tr:nth-child(" + oldy + ")").find("td:nth-child(" + oldx + ")").text(oldc);
    }
    $(this).data("x", x);
    $(this).data("y", y);
    bg = $(this).find("tr:nth-child(" + y + ")").find("td:nth-child(" + x + ")").text();
    $(this).data("content", bg);
    return $(this).find("tr:nth-child(" + y + ")").find("td:nth-child(" + x + ")").text(content);
  }
});

$.extend($.fn.world2d, {
  default_options: {},
  init: function(el, opts) {
    var color, colormap, def, height, td, tr, values, width, x, y, _i, _results;
    width = opts['width'];
    height = opts['height'];
    values = opts['values'];
    colormap = opts['colormap'];
    def = opts['default'];
    $(el).empty();
    _results = [];
    for (y = _i = 1; 1 <= height ? _i <= height : _i >= height; y = 1 <= height ? ++_i : --_i) {
      tr = $('<tr>');
      $(el).append(tr);
      _results.push((function() {
        var _j, _results1;
        _results1 = [];
        for (x = _j = 1; 1 <= width ? _j <= width : _j >= width; x = 1 <= width ? ++_j : --_j) {
          color = "white";
          if (colormap && colormap[y - 1][x - 1]) {
            color = colormap[y - 1][x - 1];
          }
          td = $('<td>').attr({
            'bgcolor': color
          });
          tr.append(td);
          _results1.push(td.text(def));
        }
        return _results1;
      })());
    }
    return _results;
  }
});

convert_map_to_colors = function(wm) {
  var data, row, y, _i, _len;
  data = [];
  for (_i = 0, _len = wm.length; _i < _len; _i++) {
    y = wm[_i];
    row = y.split('').map(function(i) {
      return map_colors[i];
    });
    data.push(row);
  }
  return data;
};

stages = {
  "010": {
    "finish": {
      "y": 10,
      "x": 10
    },
    "name": "Desert",
    "data": ["          ", "          ", "          ", "          ", "          ", "          ", "          ", "          ", "          ", "          "],
    "start": {
      "y": 1,
      "x": 1
    }
  },
  "002": {
    "finish": {
      "y": 9,
      "x": 9
    },
    "name": "Two Horizontals",
    "data": ["++*-*  * +", "**+xxxx*- ", "--++- *  *", " +-xxxx+-*", " * -*+*-* ", "  --*-*+ +", "- -*+*- +-", " --+*++ ++", "-+*++  **+", "*--* * + *"],
    "start": {
      "y": 1,
      "x": 1
    }
  },
  "004": {
    "finish": {
      "y": 9,
      "x": 9
    },
    "name": "Three Horizontals Blocking",
    "data": ["-*+ -**+- ", "+ *-++xxxx", " +  -+* **", "+xxxx+****", "* -xxxx *-", "-+ --+-+  ", "+- * -+++*", " +- ++-+--", "-++  +++* ", "+ - -+- **"],
    "start": {
      "y": 1,
      "x": 1
    }
  },
  "005": {
    "finish": {
      "y": 9,
      "x": 9
    },
    "name": "One Vertical",
    "data": [" *+*- -+++", "-+*-+* *-*", "+- -*-+-+ ", "-*-* * + +", "++ + +*--+", "*-x++* ++*", "* x * +-  ", " +x+++  *-", "  x    *- ", "***-++  *-"],
    "start": {
      "y": 1,
      "x": 1
    }
  },
  "008": {
    "finish": {
      "y": 9,
      "x": 9
    },
    "name": "Three Verticals Blocking",
    "data": ["* **+*+ - ", "+*--x-- +*", "+- +xx -+-", " *  xx *- ", "* x*xx+--+", "++x +x+- -", "+-x*++++-+", "**x  -* *-", " + +**+++*", "- + * --- "],
    "start": {
      "y": 1,
      "x": 1
    }
  },
  "009": {
    "finish": {
      "y": 9,
      "x": 9
    },
    "name": "Crosses",
    "data": ["* * +* -**", "-- *xxxx +", "**-*x  *+-", "+xxxx +*-+", "   xxxx *-", "*- **x+++-", "-   -x    ", "- ++ x-+* ", "-   -x** +", "   *- -** "],
    "start": {
      "y": 1,
      "x": 1
    }
  },
  "003": {
    "finish": {
      "y": 9,
      "x": 9
    },
    "name": "Two Horizontals Blocking",
    "data": ["+* +---++ ", "-+- xxxx *", "*-+ -***- ", "*xxxx*--- ", "     *+*  ", "+++ ***--*", "*+** --  +", "---    + +", " * -+*+++-", "*+-**-  - "],
    "start": {
      "y": 1,
      "x": 1
    }
  },
  "006": {
    "finish": {
      "y": 9,
      "x": 9
    },
    "name": "Two Verticals",
    "data": ["--  -  *++", "    --*-* ", " *x**x *+-", "--x**x- *+", "- x+*x*---", "+*x* x*-* ", "+   +  * -", "*  *++ *- ", "+** +-**+-", "--+**+-* -"],
    "start": {
      "y": 1,
      "x": 1
    }
  },
  "007": {
    "finish": {
      "y": 9,
      "x": 9
    },
    "name": "Two Verticals Blocking",
    "data": ["***  *- -*", "   *x +** ", "- **x++***", "*---x- *+-", "*+x x+*+ -", "* x- *+ + ", "+-x+-* ** ", "- x*-    *", "+ *-*+**  ", " +- ++*   "],
    "start": {
      "y": 1,
      "x": 1
    }
  },
  "001": {
    "finish": {
      "y": 9,
      "x": 9
    },
    "name": "One Horizontal",
    "data": ["  + -*+ ++", "** - *+-**", "-** ++ +-+", "-+**  *++-", "-+*xxxx+ +", "+--+*-* * ", "-**+**+*++", "+ - + +-* ", " *- +*+--*", "+* * * *-*"],
    "start": {
      "y": 1,
      "x": 1
    }
  }
};

int = function(x) {
  return parseInt(x, 10);
};

len = function(x) {
  return x.length;
};

range = function(b) {
  var _i, _results;
  return (function() {
    _results = [];
    for (var _i = 0; 0 <= b ? _i <= b : _i >= b; 0 <= b ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this);
};

shift_num = function(a, l) {
  var i, list, _i, _ref, _results;
  list = [];
  _results = [];
  for (i = _i = 0, _ref = l - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    _results.push(list.push(a.shift()));
  }
  return _results;
};

Neuron = (function() {
  function Neuron(size) {
    this.size = size;
    this.weights = [];
  }

  Neuron.prototype._sigmoid = function(value) {
    var out;
    out = 1.0 / (1.0 + Math.exp(-value));
    return out;
  };

  Neuron.prototype.forward = function(input_matrix) {
    return this._sigmoid(this.multiply(this.weights, input_matrix));
  };

  Neuron.prototype.multiply = function(matrix1, matrix2) {
    var i, message, _i, _ref, _sum;
    if (len(matrix1) === len(matrix2)) {
      _sum = 0.0;
      for (i = _i = 0, _ref = matrix1.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _sum = _sum + matrix1[i] * matrix2[i];
      }
    } else {
      message = "Matrices should have the same size " + (len(matrix1)) + " != " + (len(matrix2));
      console.log(message);
      exit;
    }
    return _sum;
  };

  Neuron.prototype.deserialize = function(list) {
    var i, _i, _ref, _results;
    this.weights = [];
    _results = [];
    for (i = _i = 1, _ref = this.size; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
      _results.push(this.weights.push(list.shift()));
    }
    return _results;
  };

  return Neuron;

})();

Layer = (function() {
  function Layer(neuron_number, weight_number) {
    var i, _i, _ref;
    this.neuron_number = neuron_number;
    this.weight_number = weight_number;
    this.neurons = [];
    for (i = _i = 0, _ref = this.neuron_number - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.neurons.push(new Neuron(this.weight_number));
    }
  }

  Layer.prototype.forward = function(input_matrix) {
    var n, outputs, _i, _len, _ref;
    outputs = [];
    _ref = this.neurons;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      outputs.push(n.forward(input_matrix));
    }
    return outputs;
  };

  Layer.prototype.deserialize = function(list) {
    var n, _i, _len, _ref, _results;
    _ref = this.neurons;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      _results.push(n.deserialize(list));
    }
    return _results;
  };

  return Layer;

})();

Network = (function() {
  function Network(structure) {
    var i, _i, _ref;
    this.layers = [];
    for (i = _i = 0, _ref = structure.length - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.layers.push(new Layer(structure[i + 1], structure[i]));
    }
  }

  Network.prototype.forward = function(input_matrix) {
    var layer, output, _i, _len, _ref;
    output = input_matrix;
    _ref = this.layers;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      layer = _ref[_i];
      output = layer.forward(output);
    }
    return output;
  };

  Network.prototype.deserialize = function(list) {
    var l, _i, _len, _ref, _results;
    _ref = this.layers;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      l = _ref[_i];
      _results.push(l.deserialize(list));
    }
    return _results;
  };

  Network.prototype.size = function() {
    return len(this.serialize());
  };

  return Network;

})();

PERSON_HEALTH = 100;

MAX_GAME_ITERATIONS = 100;

normalize_health = function(health) {
  switch (health) {
    case 'x':
      return 0.0;
    case -1:
      return 0.3;
    case 0:
      return 0.5;
    case 1:
      return 0.7;
    case -10:
      return 0.0;
  }
};

Point = (function() {
  function Point(x, y) {
    this.x = x != null ? x : 0;
    this.y = y != null ? y : 0;
  }

  Point.prototype.equals = function(other) {
    return this.x === other.x && this.y === other.y;
  };

  Point.prototype.clone = function() {
    return new Point(this.x, this.y);
  };

  Point.prototype.add = function(point) {
    this.x += point.x;
    return this.y += point.y;
  };

  return Point;

})();

WorldMap = (function() {
  function WorldMap(tiles) {
    this.tiles = [];
    this.string_import(tiles);
    this.width = tiles[0].length;
    this.height = tiles.length;
  }

  WorldMap.prototype.set_tiles = function(tiles) {
    return this.tiles = tiles;
  };

  WorldMap.prototype.get = function(point) {
    return this.tiles[point.y - 1][point.x - 1];
  };

  WorldMap.prototype.valid_point = function(point) {
    var value;
    if ((point.y > 0 && point.y <= this.height) && (point.x > 0 && point.x <= this.width)) {
      value = this.get(point);
      return value !== 'x';
    } else {
      return false;
    }
  };

  WorldMap.prototype.string_import = function(strings) {
    var ch, char_map, i, tiles, translated, _i, _j, _len, _len1;
    tiles = [];
    char_map = {
      'x': 'x',
      '-': -1,
      ' ': 0,
      '*': -10,
      '+': 1
    };
    for (_i = 0, _len = strings.length; _i < _len; _i++) {
      i = strings[_i];
      translated = [];
      for (_j = 0, _len1 = i.length; _j < _len1; _j++) {
        ch = i[_j];
        translated.push(char_map[ch]);
      }
      tiles.push(translated);
    }
    return this.tiles = tiles;
  };

  WorldMap.prototype.difference = function(mypoint, finalpoint) {
    var dx, dy;
    dx = Math.abs(mypoint.x - finalpoint.x) / this.width;
    dy = Math.abs(mypoint.y - finalpoint.y) / this.height;
    return [dx, dy];
  };

  return WorldMap;

})();

Person = (function() {
  function Person(point) {
    this.point = point;
    this.health = PERSON_HEALTH;
  }

  Person.prototype.is_dead = function() {
    return this.health <= 0;
  };

  Person.prototype.my_cell_value = function(map) {
    return map.get(this.point);
  };

  Person.prototype.has_reached_point = function(point) {
    return this.point.equals(point);
  };

  Person.prototype.apply_move_value = function(map) {
    this.health += int(this.my_cell_value(map));
    $('#health').text(this.health);
    return place_character(this.point.x, this.point.y);
  };

  Person.prototype.move = function(point) {
    return this.point.add(point);
  };

  Person.prototype.can_i_move = function(map, move) {
    var dx, dy, x, y;
    dx = move.dx;
    dy = move.dy;
    x = this.point.x + dx;
    y = this.point.y + dy;
    return map.valid_point(new Point(x, y));
  };

  return Person;

})();

Move = (function() {
  function Move(dx, dy, value) {
    this.dx = dx;
    this.dy = dy;
    this.value = value != null ? value : 0;
  }

  Move.prototype.move = function() {
    return new Point(this.dx, this.dy);
  };

  return Move;

})();

MoveNorth = (function(_super) {
  __extends(MoveNorth, _super);

  function MoveNorth(value) {
    if (value == null) {
      value = 0;
    }
    MoveNorth.__super__.constructor.call(this, 0, -1, value);
  }

  MoveNorth.prototype.move = function() {
    return MoveNorth.__super__.move.call(this);
  };

  return MoveNorth;

})(Move);

MoveSouth = (function(_super) {
  __extends(MoveSouth, _super);

  function MoveSouth(value) {
    if (value == null) {
      value = 0;
    }
    MoveSouth.__super__.constructor.call(this, 0, 1, value);
  }

  MoveSouth.prototype.move = function() {
    return MoveSouth.__super__.move.call(this);
  };

  return MoveSouth;

})(Move);

MoveWest = (function(_super) {
  __extends(MoveWest, _super);

  function MoveWest(value) {
    if (value == null) {
      value = 0;
    }
    MoveWest.__super__.constructor.call(this, -1, 0, value);
  }

  MoveWest.prototype.move = function() {
    return MoveWest.__super__.move.call(this);
  };

  return MoveWest;

})(Move);

MoveEast = (function(_super) {
  __extends(MoveEast, _super);

  function MoveEast(value) {
    if (value == null) {
      value = 0;
    }
    MoveEast.__super__.constructor.call(this, 1, 0, value);
  }

  MoveEast.prototype.move = function() {
    return MoveEast.__super__.move.call(this);
  };

  return MoveEast;

})(Move);

Environment = (function() {
  function Environment(map, enter_cell, final_cell) {
    this.map = map;
    this.enter_cell = enter_cell;
    this.final_cell = final_cell;
    this.reset();
  }

  Environment.prototype.reset = function() {
    this.person = new Person(this.enter_cell.clone());
    this.result = 0;
    return this.iterations = 0;
  };

  Environment.prototype.is_finished = function() {
    return this.person.is_dead() || this.person.has_reached_point(this.final_cell) || this.iterations > MAX_GAME_ITERATIONS;
  };

  Environment.prototype.run = function(move_obj, test_name) {
    var directions, ds, dx, dy, e, east, east_point, map, moves, n, north, north_point, person, s, selected_move, south, south_point, valid_moves, w, west, west_point, x, y;
    ds = this.map.difference(this.person.point, this.final_cell);
    dx = ds[0];
    dy = ds[1];
    this.person.apply_move_value(this.map);
    if (this.person.is_dead() || this.iterations > MAX_GAME_ITERATIONS) {
      this.result = 0 - dx - dy;
    }
    north = -1.0;
    south = -1.0;
    east = -1.0;
    west = -1.0;
    x = this.person.point.x;
    y = this.person.point.y;
    north_point = new Point(x, y - 1);
    south_point = new Point(x, y + 1);
    west_point = new Point(x - 1, y);
    east_point = new Point(x + 1, y);
    if (this.map.valid_point(north_point)) {
      north = normalize_health(this.map.get(north_point));
    }
    if (this.map.valid_point(south_point)) {
      south = normalize_health(this.map.get(south_point));
    }
    if (this.map.valid_point(west_point)) {
      west = normalize_health(this.map.get(west_point));
    }
    if (this.map.valid_point(east_point)) {
      east = normalize_health(this.map.get(east_point));
    }
    directions = move_obj.run(north, south, west, east, dx, dy);
    n = directions[0];
    s = directions[1];
    w = directions[2];
    e = directions[3];
    person = this.person;
    map = this.map;
    moves = [new MoveNorth(n), new MoveSouth(s), new MoveWest(w), new MoveEast(e)];
    valid_moves = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = moves.length; _i < _len; _i++) {
        x = moves[_i];
        if (person.can_i_move(map, x) === true) {
          _results.push(x);
        }
      }
      return _results;
    })();
    valid_moves.sort(function(a, b) {
      return b.value - a.value;
    });
    selected_move = valid_moves[0];
    this.person.move(selected_move.move());
    this.iterations++;
    if (!this.is_finished()) {
      setTimeout(((function(_this) {
        return function() {
          _this.run(move_obj, test_name);
        };
      })(this)), 1000);
    } else {
      console.log('finished');
      this.person.apply_move_value(this.map);
      $('#results').append($('<li>').append(test_name + " : " + this.person.health));
      setTimeout((function() {
        run_stage(1);
      }), 2000);
    }
    return this.result = this.person.health + MAX_GAME_ITERATIONS - this.iterations;
  };

  return Environment;

})();

data = [0.32326523174214883, 0.1975164153202762, 0.4274634567562191, 0.9104155155435582, 0.7093427806309657, 0.058106673895569894, 0.24316963156365112, 0.9964265910539323, 0.3758163976564397, 0.3155816489584621, 0.013393122391257561, 0.5809783250889199, 0.10795677465673825, 0.3798516348711246, 0.721526301160357, 0.9797333103138433, 0.5745434039357836, 0.8768018651421203, 0.9828762666921318, 0.7169568239480663];

neural_def = [6, 2, 4];

network = new Network(neural_def);

network.deserialize(data);

MoveObject = (function() {
  function MoveObject(network) {
    this.network = network;
  }

  MoveObject.prototype.run = function(north, south, west, east, dx, dy) {
    return this.network.forward([north, south, west, east, dx, dy]);
  };

  return MoveObject;

})();

map_colors = {
  ' ': 'white',
  'x': 'black',
  '*': 'red',
  '-': 'orange',
  '+': 'green'
};

place_character = function(x, y) {
  return $('#test').place(x, y, '*');
};

all_stages = Object.keys(stages);

run_stage = function() {
  var colormap, env, finish, id, name, start;
  console.log('inside again');
  id = all_stages.shift();
  if (id) {
    console.log("id = " + id);
    colormap = convert_map_to_colors(stages[id]['data']);
    name = stages[id]['name'];
    $('#title').text(name);
    start = new Point(stages[id]['start']['x'], stages[id]['start']['y']);
    finish = new Point(stages[id]['finish']['x'], stages[id]['finish']['y']);
    $('#test').world2d({
      'width': 10,
      'height': 10,
      'default': ' ',
      'colormap': colormap
    });
    env = new Environment(new WorldMap(stages[id]['data']), start, finish);
    return env.run(new MoveObject(network), name);
  }
};

$(function() {
  return $('#neural').val('NiwyLDQ6MC4zMjMyNjUyMzE3NDIxNDg4MywwLjE5NzUxNjQxNTMyMDI3NjIsMC40Mjc0NjM0NTY3NTYyMTkxLDAuOTEwNDE1NTE1NTQzNTU4MiwwLjcwOTM0Mjc4MDYzMDk2NTcsMC4wNTgxMDY2NzM4OTU1Njk4OTQsMC4yNDMxNjk2MzE1NjM2NTExMiwwLjk5NjQyNjU5MTA1MzkzMjMsMC4zNzU4MTYzOTc2NTY0Mzk3LDAuMzE1NTgxNjQ4OTU4NDYyMSwwLjAxMzM5MzEyMjM5MTI1NzU2MSwwLjU4MDk3ODMyNTA4ODkxOTksMC4xMDc5NTY3NzQ2NTY3MzgyNSwwLjM3OTg1MTYzNDg3MTEyNDYsMC43MjE1MjYzMDExNjAzNTcsMC45Nzk3MzMzMTAzMTM4NDMzLDAuNTc0NTQzNDAzOTM1NzgzNiwwLjg3NjgwMTg2NTE0MjEyMDMsMC45ODI4NzYyNjY2OTIxMzE4LDAuNzE2OTU2ODIzOTQ4MDY2Mw==');
});

$('#run').click(function(evt) {
  var str, tokens;
  str = decodeBase64($('#neural').val());
  tokens = str.split(':');
  neural_def = tokens[0].split(',');
  $('#struct').text(tokens[0]);
  $('#data').text(tokens[1]);
  data = tokens[1].split(',');
  return run_stage();
});
